%% -------------------------------------------------------------------
%%
%% Copyright (c) 2011 Basho Technologies, Inc.
%%
%% This file is provided to you under the Apache License,
%% Version 2.0 (the "License"); you may not use this file
%% except in compliance with the License.  You may obtain
%% a copy of the License at
%%
%%   http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing,
%% software distributed under the License is distributed on an
%% "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
%% KIND, either express or implied.  See the License for the
%% specific language governing permissions and limitations
%% under the License.
%%
%% -------------------------------------------------------------------

%% @doc Query indexes stored on the local Riak KV vnode sharing the
%%      same index as the pipe vnode owning this worker.  This is the
%%      same idea as riak_kv_pipe_get, but with the `listkeys'
%%      operation instead of `get'.
%%
%%      Inputs to this worker may be `{Bucket :: binary, Query ::
%%      query()}'.  `Query' may take the form of either `{eq, Index,
%%      Key}' or `{range, Index, StartKey, EndKey}'.
%%
%%      This fitting also understands cover input, as generated by
%%      `riak_pipe_qcover_fsm'.  When processing cover input, the
%%      `FilterVNodes' parameter is passed along to the KV vnode for
%%      filtering there.  (When not processing cover input, the KV
%%      vnode is passed an empty `FilterVNodes' list.)
%%
%%      The convenience function `queue_existing_pipe/3' can be used
%%      to list the index matches directly into an existing pipe.

-module(riak_kv_pipe_index).
-behaviour(riak_pipe_vnode_worker).

-export([init/2,
         process/3,
         done/1,
         queue_existing_pipe/4,
         queue_existing_pipe/5]).

-include("riak_kv_vnode.hrl").
-include_lib("riak_pipe/include/riak_pipe.hrl").
-include_lib("riak_pipe/include/riak_pipe_log.hrl").

-record(state, {p :: riak_pipe_vnode:partition(),
                fd :: riak_pipe_fitting:details()
            }).
-opaque state() :: #state{}.
-type index_keydata() :: 
    {{riak_object:bucket(), riak_object:key()}, undefined|list({atom(), term()})}.
-type prereduce_fun() ::
    fun((index_keydata()) -> index_keydata()|none).
-type prereduce_def() ::
    {atom(), atom(), tuple()}.
-type query_input() ::
    {cover,
        list({riak_pipe_vnode:partition(), node()}),
        {riak_object:bucket(), riak_index:query_def(), list(prereduce_fun())}}
    | {riak_object:bucket(), riak_index:query_def(), list(prereduce_fun())}.

-export_type([state/0, index_keydata/0, prereduce_fun/0, prereduce_def/0]).

%% @doc Init just stashes the `Partition' and `FittingDetails' for later.
-spec init(riak_pipe_vnode:partition(), riak_pipe_fitting:details()) ->
         {ok, state()}.
init(Partition, FittingDetails) ->
    {ok, #state{p=Partition, fd=FittingDetails}}.

%% @doc Process queries indexes on the KV vnode, according to the
%% input bucket and query.
-spec process(query_input(), boolean(), state()) -> {ok | {error, term()}, state()}.
process(Input, _Last, #state{p=Partition, fd=FittingDetails}=State) ->
    case Input of
        {cover, FilterVNodes, {Bucket, Query, PRFuns}} ->
            ok;
        {Bucket, Query, PRFuns} ->
            FilterVNodes = []
    end,
    ReqId = erlang:phash2({self(), os:timestamp()}), % stolen from riak_client
    riak_core_vnode_master:coverage(
      riak_kv_index_fsm:req(Bucket, none, Query),
      {Partition, node()},
      FilterVNodes,
      {raw, ReqId, self()},
      riak_kv_vnode_master),
    {keysend_loop(ReqId, Partition, FittingDetails, PRFuns),
        State}.

keysend_loop(ReqId, Partition, FittingDetails, PRs) ->
    receive
        {ReqId, {error, _Reason} = ER} ->
            ER;
        {ReqId, {From, Bucket, Keys}} ->
            case keysend(Bucket, Keys, Partition, FittingDetails, PRs) of
                ok ->
                    _ = riak_kv_vnode:ack_keys(From),
                    keysend_loop(ReqId, Partition, FittingDetails, PRs);
                ER ->
                    ER
            end;
        {ReqId, {Bucket, Keys}} ->
            case keysend(Bucket, Keys, Partition, FittingDetails, PRs) of
                ok ->
                    keysend_loop(ReqId, Partition, FittingDetails, PRs);
                ER ->
                    ER
            end;
        {ReqId, done} ->
            ok
    end.

keysend(_Bucket, [], _Partition, _FittingDetails, _PRs) ->
    ok;
keysend(Bucket, [{o,Key,BinRiakObj}|Keys], Partition, FittingDetails, PRs) ->
    RiakObj = riak_object:from_binary(Bucket, Key, BinRiakObj),
    Out = {ok, RiakObj, undefined},
    case riak_pipe_vnode_worker:send_output(Out, Partition, FittingDetails) of
        ok ->
            keysend(Bucket, Keys, Partition, FittingDetails, PRs);
        ER ->
            ER
    end;
keysend(Bucket, [Key | Keys], Partition, FittingDetails, PRs) ->
    case lists:foldl(fun(F, Acc) -> F(Acc) end, strip_indexkey(Bucket, Key), PRs) of
        none ->
            keysend(Bucket, Keys, Partition, FittingDetails, PRs);
        IndexTerm ->        
            case riak_pipe_vnode_worker:send_output(IndexTerm, Partition, FittingDetails) of
                ok ->
                    keysend(Bucket, Keys, Partition, FittingDetails, PRs);
                ER ->
                    ER
            end
    end.

%% @doc Remove the type from the bucket, and pass through a returned term as KeyData
-spec strip_indexkey(riak_object:bucket(), riak_object:key()|
                        {binary(), riak_object:key()})
                            -> index_keydata().
strip_indexkey(Bucket, KeyPlusTerm) ->
    {Key, Term} = strip(KeyPlusTerm),
    {{Bucket, Key}, Term}.

-spec strip({binary(), binary()}|binary())
        -> {binary(), list({term, binary()})}|undefined.
strip({IndexTerm, Key}) ->
    {Key, [{term, IndexTerm}]};
strip(Key) when is_binary(Key) ->
    {Key, undefined}.

%% @doc Unused.
-spec done(state()) -> ok.
done(_State) ->
    ok.

%% Convenience

-type bucket_or_filter() ::
        binary() | {binary(), binary()} | {binary(), list()} |
        {{binary(), binary()}, list()}.
        % Bucket may be typed bucket

queue_existing_pipe(Pipe, Bucket, Query, Timeout) ->
    queue_existing_pipe(Pipe, Bucket, Query, [], Timeout).

%% @doc Query and index, and send the results as inputs to the
%%      given pipe.  This starts a new pipe with one fitting
%%      (`riak_kv_pipe_index'), with its sink pointed at the
%%      destination pipe.  The `riak_pipe_qcover_fsm' module is used
%%      to trigger querying on the appropriate vnodes.  The `eoi'
%%      message is sent to the pipe as soon as it is confirmed that
%%      all querying processes have started.
%%
%%      Note that log/trace messages are sent to the sink of the
%%      original pipe. It is expected that that sink is an `fsm' type.
-spec queue_existing_pipe(riak_pipe:pipe(),
                          bucket_or_filter(),
                          {eq, Index::binary(), Value::term()}
                          |{range, Index::binary(),
                            Start::term(), End::term()}
                          |riak_index:query_def(),
                          list(prereduce_def()),
                          timeout()) ->
         ok | {error, Reason :: term()}.
queue_existing_pipe(Pipe, Bucket, Query, FunDefs, Timeout) ->
    %% make our tiny pipe
    [{_Name, Head}|_] = Pipe#pipe.fittings,
    Period = riak_kv_mrc_pipe:sink_sync_period(),
    {ok, LKP} = riak_pipe:exec([#fitting_spec{name=index,
                                              module=?MODULE,
                                              nval=1}],
                               [{sink, Head},
                                {trace, [error]},
                                {log, {sink, Pipe#pipe.sink}},
                                {sink_type, {fsm, Period, infinity}}]),

    %% setup the cover operation
    ReqId = erlang:phash2({self(), os:timestamp()}), %% stolen from riak_client
    BucketProps = riak_core_bucket:get_bucket(Bucket),
    NVal = proplists:get_value(n_val, BucketProps),
    PRFuns = lists:map(fun({M, F, A}) -> M:F(A) end, FunDefs),
    {ok, Sender} = riak_pipe_qcover_sup:start_qcover_fsm(
                     [{raw, ReqId, self()},
                      [LKP, {Bucket, Query, PRFuns}, NVal]]),

    %% wait for cover to hit everything
    {RealTO, TOReason} =
        try erlang:link(Sender) of
            true ->
                %% Sender was alive - wait as expected
                {Timeout, timeout}
        catch error:noproc ->
                %% Sender finished early; it's always spawned locally,
                %% so we'll get a noproc exit, instead of an exit signal

                %% messages had better already be in our mailbox,
                %% don't wait any extra time for them
                {0,
                 %% we'll have no idea what its failure was, unless it
                 %% sent us an error message
                 index_coverage_failure}
        end,

    receive
        {ReqId, done} ->
            %% this eoi will flow into the other pipe
            riak_pipe:eoi(LKP),
            ok;
        {ReqId, Error} ->
            %% this destroy should not harm the other pipe
            riak_pipe:destroy(LKP),
            Error
    after RealTO ->
            %% this destroy should not harm the other pipe
            riak_pipe:destroy(LKP),
            {error, TOReason}
    end.
